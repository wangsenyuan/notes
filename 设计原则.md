1. SOLID原则
   1. Single Responsibility, 一个类应该只负责一件事情，并且把该事情做好
   2. Open/Close  对扩展公开，对修改封闭
   3. Liscov替换，子类必须实现父类的接口，在调用时，可以完全替换父类
   4. Interface Segregation，
   ```
   many client-specific interfaces are better than one general-purpose interface
   ```
   单个interface应该只描述一个（多个内聚）能力，调用方只引用它所需要的能力；比如有多个接口描述表的CRUD的能力，Selectable, Updatable, Deleteable。对于某些表，可以具备所有这些能力，实现所有的接口；有一些表只读，则只需要实现Selectable。对于调用方，可以按照具体的需要，只读，更新，或者删除，接收相应的接口类型。这样也可以防止把只读表传入更新，或删除接口。
   5. Dependency inversion, 依赖注入； client依赖抽象接口而不是具体的实现，实现也依赖抽象接口；通过抽象接口定义契约； 
   这个原则依赖于Interface Segregation,良好定义的接口，使得依赖注入更加明确；也依赖于Liscov替换；一般应该注入抽象接口，那么具体实现的替换，可以保证调用方不做修改；通过提供mock的依赖，也使得调用方的测试更加方便；
2. 迪米特法则
   这条指Client应该尽可能少的知道Dependency的实现细节；它和SOLID原则也是紧密相关的的，一个符合SOLID原则的设计，也符合迪米特法则：Client注入抽象接口，避免和具体的实现隅合；抽象接口的定义尽量单一，也更有利于隐藏实现细节；
3. 组合优于继承
   应该尽量通过组合其他组件来实现功能，而不是通过扩展（继承）已有的组件；大部分情况（如果不是全部）都可以通过组合来完成任务，（golang没有提供继承的方式）。
   几个优点：
   1. 组合是一个树形结构，可以将复杂的问题，不断的分解，变成小的问题；
   2. 小的结构，也比较容易测试，也更加容易被复用；
   3. 相对于继承，（在大部分情况下）更符合现实的模型；
   4. 对于Dependency的修改更加健壮；如果继承了某个父组件，父组件接口定义修改， 将直接导致该组件不可用，必须跟随其一起变化；但如果是组合，在最好的情况下，将不需要做修改；最坏的情况，是替换掉该组件；