1. Monolithic
    1. 开发效率低，开发人员多的时候，任务分配，功能划分界限模糊；
    2. 应用扩展性差，在AFK扩展立方中，只能按照X轴水平扩展；
    3. 运行稳定性差，局部的小问题， 就可以让整个应用down机。小的改动， 就必须重新部署整个应用。
    4. 系统的演进比较迟缓，无法快速的应用新的框架，技术，语言，理念等；
2. micro service
    1. 业务功能划分清楚，模型清晰，内聚；开发人员可以专注于部分service，成为该领域的专家；提高业务能力；
    2. AFK立方中Y轴扩展；单独的service可以按需X轴扩展；
    3. 系统运行稳定，（设计合理）问题可以隔离在单个service中，甚至可以忍受局部的down机；
    4. 单个service可以采用新的技术，甚至语言；可以快速演化；
    5. 运维难度增加，DevOps，CI/CD等要求高。
    6. 服务注册/发现，路由，断路器，配置管理，服务调用协议/消息/总线
3. kubernetes & docker
    1. 简化了微服务的部署和运维
    2. 服务稳定性提高（当某个服务意外停机后，kubernetes会重新部署一个新的服务替代），部署时也能做到不停机（rollout机制）
    3. 服务注册（label selector），发现（访问service，而不是pod），负载均衡，路由（service 将请求转发给pod）
    4. 资源配额管理
    5. 对应用非侵入或少侵入；应用基本不需要修改， 就可以被打包部署；
    6. AFK扩展，X轴水平（scale pod），Y轴功能划分（多服务），namespace也可用于根据数据的划分。
    7. 鼓励小而精的应用；
    8. 应用环境统一，可裁剪
4. 采用微服务需要考虑的问题：
    1. 领域模型定义是否清晰，边界是否完整。如果没有认真地设计模型，而只是把一些对象、方法移动到独立的service里面，可能得到的只是一个entity service。在面临新的业务需求时，修改任然会非常艰难，而陷入堆功能的窘境；
    2. 使用微服务必然会给系统带来更多的复杂性，服务注册发现，链路监控，错误处理，事务完整性，对象拓扑改变等挑战，必须要有一个清晰的计划去处理；
    3. 对微服务的调用，性能必然要劣于直接方法调用，以经验看，方法调用大概在1毫秒内，微服务RPC调用，大概在10毫秒。越简单直接的调用，这个差距越明显。因为复杂的调用，处理时间大部分在数据库搜索，或业务处理。使用微服务必须要对这种性能降级有所准备；事务完整性也很难保证。可以采用类似补偿机制，事后定时检查纠正等处理；微服务的异常处理也需要仔细考虑。在单一系统中，抛出异常，错误比较容易定位。但在多系统中，抛出异常对于调用方将不再那么直观。因为通过网络调用后，或者RPC框架处理后，真正的root cause有可能会被掩盖掉。这种情况下，可以设计详细的error code以对于业务错误。并和链路监控同时使用，在发生错误的时候，将调用方的错误信息和服务的错误信息匹配起来。
    4. 远程调用和本地调用，本质上是不一样的。本地调用可以提供细粒度的方法，供调用方去组合选择，而远程调用应该提供粗粒度的方法，在一次调用中，尽可能多的返回信息，避免过多的调用。这也是微服务需要定义完整领域模型的原因之一。